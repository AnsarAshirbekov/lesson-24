# а) Загрузите массив json – объектов с сайта jsonplaceholder, используя
# библиотеку aiohttp.
# б) Сохраните циклом каждый в отдельный файл, в одну новую папку.

import json
import os
import aiohttp
# Библиотека aiohttp работает практически также, как и requests, для выполнения HTTP запросов в Python.
# Основное различие между ними это подход к выполнению запросов. requests выполняет запросы СИНХРОННО,
# а aiohttp - АСИНХРОННО. 
# Синхронность в программировании подразумевает под собой последовательное выполнение функций.
# То есть если мы запускаем несколько в функций в коде, то они будут выполняться последовательно одна за другой,
# и вторая не начнет свое выполнение, пока не выполнится первая, она будет блокировать поток выполнения до тех пор,
# пока не выполнится первая функция. В случае HTTP-запросов, мы будем ждать ответа от сервера и ничего другого делать 
# не будем, пока не получим ответ.
# Асинхронность же позволяет выполнять функции параллельно без блокировки основного потока выполнения. То есть одна функция
# не будет ждать другую, она будет выполняться, когда мы это ей скажем. Это особенно полезно для создания высокопроизводительных
# веб-приложений и микросервисов, когда мы обрабатываем несколько запросов сразу.

# Чтобы работать с асинхронностью в Python необходима библиотека asyncio
import asyncio
# Без нее библиотека aiohttp не имеет смысла, потому что она специально предназначена для работы в асинхронных функциях,
# чтобы выполнять асинхронные HTTP-запросы. 
# Благодаря библиотеке asyncio мы теперь можем создавать асинхронные функции, то есть такие функции, выполнение которых 
# можно поставить на паузу в определенном месте и перейти к выполнению другой асинхронной функции.
# Чтобы обозначить что функция является асинхронной, нужно прописать перед ней флаг acync

# Создадим асинхронную функцию для получения запроса с сайта jsonplaceholder
async def fetch_data(url): # этой функции мы будем передавать какую-то ссылку
    # чтобы выполнить HTTP-запрос в асинхронной функции, нужно использовать контекстный менеджер with и обязательно перед 
    # ставить флаг async чтобы указать, что действие будет выполняться асинхронно, то есть не блокировать основной поток 
    # выполнения и дать другим асинхронным функциям выполняться
    async with aiohttp.request('GET', url) as response: # используем функцию request из aiohttp, который принимает метод
                                                        # для запроса и ссылку url, с которой будет выводиться запрос
        # далее мы должны будем полученный ответ в формате JSON преобразовать в объект Python,
        # но здесь уже добавляем другой флаг для асинхронных функций - await. Это как раз тот самый указатель приостановки
        # асинхронной функции. Наталкиваясь на него, основной поток приостанавливает выполнение функции и переходит к 
        # выполнению другой, до тех пор пока действие после await не выполнится.
        return await response.json()
    
# Как бы это функция выглядела бы в случае обычного синхронного подхода выполнения с использованием requests:
# def fetch_data(url):
#     response = requests.get(url)
#     return response.json()

# Если не использовать флаги async и await асинхронных функциях, то можно нарваться на такое действие, которое заблокирует
# основной поток выполнения функции, он будет ждать пока действие не выполнится и не будет переходить к другой функции,
# то есть будет работать синхронно, тогда здесь весь смысл использования асинхронности теряется.

# Теперь создадим асинхронную функцию для создания новой папки (если ее нет) и циклической записи в нее файлов
# Для работы с файлами в асинхронном программировании есть еще одна библиотека - aiofiles
import aiofiles
async def save_files(data): # она будет принимать объект Python (список словарей JSON) получаем из предыдущей функции
    # повторяем все тоже самое, что и было в предыдущей задаче
    current_dir = os.getcwd()
    folder_name = 'JSON Folder'
    path = os.path.join(current_dir, folder_name)
    os.makedirs(path, exist_ok=True)
    for d in data:
        file_name = f'data_{d["id"]}.json'
        file_path = os.path.join(path, file_name)
        # Далее у нас в предыдущей задаче шел with, но мы помним что перед ним нужно ставить флаг async, также там была 
        # функция open, но нам здесь не подойдет обычная функция open, нам нужен ее вариант из библиотеки aiofiles 
        async with aiofiles.open(file_path, 'w') as file:
            # здесь не подойдет использование json.dump(), как в предыдущей задаче, потому что это функция работает 
            # синхронно и будет блокировать основной поток, а нам здесь обязательно нужно поставить флаг await. 
            # json.dump() не поддерживает awaitable, поэтому мы не можем перед ним поставить await. Но так как мы используем
            # open из aiofiles мы можем использовать его функцию write(), обычный open и его write() не поддерживает await.
            # Но write() принимает только строку, а json.dump() возвращает файл, поэтому используем другую функцию 
            # json.dumps(), которая принимает словарь и возращает JSON строку
            await file.write(json.dumps(d))

# Асинхронные функции нельзя запускать так, как обычные, просто вызвать их, передав аргументы. Если так сделать, то 
# результатом будет просто объекты этих самых функций, а не результат их действия. Чтобы запускать асинхронные функции
# существует такая штука как event loop - событийный цикл. Это то что запускает их работу.

# Но для начала нужно сделать так, чтобы эти асинхронные функции тоже работали асинхронно внутри какой-то другой функции.
# Для таких случаев обычно создают отдельную главную асинхронную функцию, в которую помещают остальные функции. 
async def main():
    # Прописываем ссылку, откуда будем брать HTTP-запрос..
    url = "https://jsonplaceholder.typicode.com/users"
    # и передаем ее в первую функцию. Здесь уже ставим await, чтобы перейти на другую функцию, пока эта выполняется 
    data = await fetch_data(url)
    # Результатом ее выполнения будет переменная data, которую передаем второй функции
    await save_files(data)

if __name__ == "__main__":
    # А теперь запускаем событийный цикл через функцию run() из asyncio, передав ему главную функцию main
    asyncio.run(main())